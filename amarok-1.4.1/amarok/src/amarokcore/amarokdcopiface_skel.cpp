/****************************************************************************
**
** DCOP Skeleton generated by dcopidl2cpp from amarokdcopiface.kidl
**
** WARNING! All changes made in this file will be lost!
**
*****************************************************************************/

#include "./amarokdcopiface.h"

#include <kdatastream.h>
#include <qasciidict.h>


static const int AmarokPlayerInterface_fhash = 71;
static const char* const AmarokPlayerInterface_ftable[69][3] = {
    { "QString", "version()", "version()" },
    { "bool", "dynamicModeStatus()", "dynamicModeStatus()" },
    { "bool", "equalizerEnabled()", "equalizerEnabled()" },
    { "bool", "osdEnabled()", "osdEnabled()" },
    { "bool", "isPlaying()", "isPlaying()" },
    { "bool", "randomModeStatus()", "randomModeStatus()" },
    { "bool", "repeatPlaylistStatus()", "repeatPlaylistStatus()" },
    { "bool", "repeatTrackStatus()", "repeatTrackStatus()" },
    { "int", "getVolume()", "getVolume()" },
    { "int", "sampleRate()", "sampleRate()" },
    { "int", "score()", "score()" },
    { "int", "rating()", "rating()" },
    { "int", "status()", "status()" },
    { "int", "trackCurrentTime()", "trackCurrentTime()" },
    { "int", "trackPlayCounter()", "trackPlayCounter()" },
    { "int", "trackTotalTime()", "trackTotalTime()" },
    { "QString", "album()", "album()" },
    { "QString", "artist()", "artist()" },
    { "QString", "bitrate()", "bitrate()" },
    { "QString", "comment()", "comment()" },
    { "QString", "coverImage()", "coverImage()" },
    { "QString", "currentTime()", "currentTime()" },
    { "QString", "encodedURL()", "encodedURL()" },
    { "QString", "engine()", "engine()" },
    { "QString", "genre()", "genre()" },
    { "QString", "lyrics()", "lyrics()" },
    { "QString", "lyricsByPath(QString)", "lyricsByPath(QString path)" },
    { "QString", "nowPlaying()", "nowPlaying()" },
    { "QString", "path()", "path()" },
    { "QString", "setContextStyle(QString)", "setContextStyle(QString)" },
    { "QString", "title()", "title()" },
    { "QString", "totalTime()", "totalTime()" },
    { "QString", "track()", "track()" },
    { "QString", "type()", "type()" },
    { "QString", "year()", "year()" },
    { "void", "configEqualizer()", "configEqualizer()" },
    { "void", "enableOSD(bool)", "enableOSD(bool enable)" },
    { "void", "enableRandomMode(bool)", "enableRandomMode(bool enable)" },
    { "void", "enableRepeatPlaylist(bool)", "enableRepeatPlaylist(bool enable)" },
    { "void", "enableRepeatTrack(bool)", "enableRepeatTrack(bool enable)" },
    { "void", "mediaDeviceMount()", "mediaDeviceMount()" },
    { "void", "mediaDeviceUmount()", "mediaDeviceUmount()" },
    { "void", "mute()", "mute()" },
    { "void", "next()", "next()" },
    { "void", "pause()", "pause()" },
    { "void", "play()", "play()" },
    { "void", "playPause()", "playPause()" },
    { "void", "prev()", "prev()" },
    { "void", "queueForTransfer(KURL)", "queueForTransfer(KURL url)" },
    { "void", "seek(int)", "seek(int s)" },
    { "void", "seekRelative(int)", "seekRelative(int s)" },
    { "void", "setEqualizer(int,int,int,int,int,int,int,int,int,int,int)", "setEqualizer(int,int,int,int,int,int,int,int,int,int,int)" },
    { "void", "setEqualizerEnabled(bool)", "setEqualizerEnabled(bool active)" },
    { "void", "setEqualizerPreset(QString)", "setEqualizerPreset(QString name)" },
    { "void", "setLyricsByPath(QString,QString)", "setLyricsByPath(QString url,QString lyrics)" },
    { "void", "setScore(int)", "setScore(int score)" },
    { "void", "setScoreByPath(QString,int)", "setScoreByPath(QString url,int score)" },
    { "void", "setRating(int)", "setRating(int rating)" },
    { "void", "setRatingByPath(QString,int)", "setRatingByPath(QString url,int rating)" },
    { "void", "setVolume(int)", "setVolume(int volume)" },
    { "void", "setVolumeRelative(int)", "setVolumeRelative(int ticks)" },
    { "void", "showBrowser(QString)", "showBrowser(QString browser)" },
    { "void", "showOSD()", "showOSD()" },
    { "void", "stop()", "stop()" },
    { "void", "transferDeviceFiles()", "transferDeviceFiles()" },
    { "void", "volumeDown()", "volumeDown()" },
    { "void", "volumeUp()", "volumeUp()" },
    { "void", "transferCliArgs(QStringList)", "transferCliArgs(QStringList args)" },
    { 0, 0, 0 }
};
static const int AmarokPlayerInterface_ftable_hiddens[68] = {
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
};

bool AmarokPlayerInterface::process(const QCString &fun, const QByteArray &data, QCString& replyType, QByteArray &replyData)
{
    static QAsciiDict<int>* fdict = 0;
    if ( !fdict ) {
	fdict = new QAsciiDict<int>( AmarokPlayerInterface_fhash, true, false );
	for ( int i = 0; AmarokPlayerInterface_ftable[i][1]; i++ )
	    fdict->insert( AmarokPlayerInterface_ftable[i][1],  new int( i ) );
    }
    int* fp = fdict->find( fun );
    switch ( fp?*fp:-1) {
    case 0: { // QString version()
	replyType = AmarokPlayerInterface_ftable[0][0]; 
	QDataStream _replyStream( replyData, IO_WriteOnly );
	_replyStream << version( );
    } break;
    case 1: { // bool dynamicModeStatus()
	replyType = AmarokPlayerInterface_ftable[1][0]; 
	QDataStream _replyStream( replyData, IO_WriteOnly );
	_replyStream << dynamicModeStatus( );
    } break;
    case 2: { // bool equalizerEnabled()
	replyType = AmarokPlayerInterface_ftable[2][0]; 
	QDataStream _replyStream( replyData, IO_WriteOnly );
	_replyStream << equalizerEnabled( );
    } break;
    case 3: { // bool osdEnabled()
	replyType = AmarokPlayerInterface_ftable[3][0]; 
	QDataStream _replyStream( replyData, IO_WriteOnly );
	_replyStream << osdEnabled( );
    } break;
    case 4: { // bool isPlaying()
	replyType = AmarokPlayerInterface_ftable[4][0]; 
	QDataStream _replyStream( replyData, IO_WriteOnly );
	_replyStream << isPlaying( );
    } break;
    case 5: { // bool randomModeStatus()
	replyType = AmarokPlayerInterface_ftable[5][0]; 
	QDataStream _replyStream( replyData, IO_WriteOnly );
	_replyStream << randomModeStatus( );
    } break;
    case 6: { // bool repeatPlaylistStatus()
	replyType = AmarokPlayerInterface_ftable[6][0]; 
	QDataStream _replyStream( replyData, IO_WriteOnly );
	_replyStream << repeatPlaylistStatus( );
    } break;
    case 7: { // bool repeatTrackStatus()
	replyType = AmarokPlayerInterface_ftable[7][0]; 
	QDataStream _replyStream( replyData, IO_WriteOnly );
	_replyStream << repeatTrackStatus( );
    } break;
    case 8: { // int getVolume()
	replyType = AmarokPlayerInterface_ftable[8][0]; 
	QDataStream _replyStream( replyData, IO_WriteOnly );
	_replyStream << getVolume( );
    } break;
    case 9: { // int sampleRate()
	replyType = AmarokPlayerInterface_ftable[9][0]; 
	QDataStream _replyStream( replyData, IO_WriteOnly );
	_replyStream << sampleRate( );
    } break;
    case 10: { // int score()
	replyType = AmarokPlayerInterface_ftable[10][0]; 
	QDataStream _replyStream( replyData, IO_WriteOnly );
	_replyStream << score( );
    } break;
    case 11: { // int rating()
	replyType = AmarokPlayerInterface_ftable[11][0]; 
	QDataStream _replyStream( replyData, IO_WriteOnly );
	_replyStream << rating( );
    } break;
    case 12: { // int status()
	replyType = AmarokPlayerInterface_ftable[12][0]; 
	QDataStream _replyStream( replyData, IO_WriteOnly );
	_replyStream << status( );
    } break;
    case 13: { // int trackCurrentTime()
	replyType = AmarokPlayerInterface_ftable[13][0]; 
	QDataStream _replyStream( replyData, IO_WriteOnly );
	_replyStream << trackCurrentTime( );
    } break;
    case 14: { // int trackPlayCounter()
	replyType = AmarokPlayerInterface_ftable[14][0]; 
	QDataStream _replyStream( replyData, IO_WriteOnly );
	_replyStream << trackPlayCounter( );
    } break;
    case 15: { // int trackTotalTime()
	replyType = AmarokPlayerInterface_ftable[15][0]; 
	QDataStream _replyStream( replyData, IO_WriteOnly );
	_replyStream << trackTotalTime( );
    } break;
    case 16: { // QString album()
	replyType = AmarokPlayerInterface_ftable[16][0]; 
	QDataStream _replyStream( replyData, IO_WriteOnly );
	_replyStream << album( );
    } break;
    case 17: { // QString artist()
	replyType = AmarokPlayerInterface_ftable[17][0]; 
	QDataStream _replyStream( replyData, IO_WriteOnly );
	_replyStream << artist( );
    } break;
    case 18: { // QString bitrate()
	replyType = AmarokPlayerInterface_ftable[18][0]; 
	QDataStream _replyStream( replyData, IO_WriteOnly );
	_replyStream << bitrate( );
    } break;
    case 19: { // QString comment()
	replyType = AmarokPlayerInterface_ftable[19][0]; 
	QDataStream _replyStream( replyData, IO_WriteOnly );
	_replyStream << comment( );
    } break;
    case 20: { // QString coverImage()
	replyType = AmarokPlayerInterface_ftable[20][0]; 
	QDataStream _replyStream( replyData, IO_WriteOnly );
	_replyStream << coverImage( );
    } break;
    case 21: { // QString currentTime()
	replyType = AmarokPlayerInterface_ftable[21][0]; 
	QDataStream _replyStream( replyData, IO_WriteOnly );
	_replyStream << currentTime( );
    } break;
    case 22: { // QString encodedURL()
	replyType = AmarokPlayerInterface_ftable[22][0]; 
	QDataStream _replyStream( replyData, IO_WriteOnly );
	_replyStream << encodedURL( );
    } break;
    case 23: { // QString engine()
	replyType = AmarokPlayerInterface_ftable[23][0]; 
	QDataStream _replyStream( replyData, IO_WriteOnly );
	_replyStream << engine( );
    } break;
    case 24: { // QString genre()
	replyType = AmarokPlayerInterface_ftable[24][0]; 
	QDataStream _replyStream( replyData, IO_WriteOnly );
	_replyStream << genre( );
    } break;
    case 25: { // QString lyrics()
	replyType = AmarokPlayerInterface_ftable[25][0]; 
	QDataStream _replyStream( replyData, IO_WriteOnly );
	_replyStream << lyrics( );
    } break;
    case 26: { // QString lyricsByPath(QString)
	QString arg0;
	QDataStream arg( data, IO_ReadOnly );
	if (arg.atEnd()) return false;
	arg >> arg0;
	replyType = AmarokPlayerInterface_ftable[26][0]; 
	QDataStream _replyStream( replyData, IO_WriteOnly );
	_replyStream << lyricsByPath(arg0 );
    } break;
    case 27: { // QString nowPlaying()
	replyType = AmarokPlayerInterface_ftable[27][0]; 
	QDataStream _replyStream( replyData, IO_WriteOnly );
	_replyStream << nowPlaying( );
    } break;
    case 28: { // QString path()
	replyType = AmarokPlayerInterface_ftable[28][0]; 
	QDataStream _replyStream( replyData, IO_WriteOnly );
	_replyStream << path( );
    } break;
    case 29: { // QString setContextStyle(QString)
	QString arg0;
	QDataStream arg( data, IO_ReadOnly );
	if (arg.atEnd()) return false;
	arg >> arg0;
	replyType = AmarokPlayerInterface_ftable[29][0]; 
	QDataStream _replyStream( replyData, IO_WriteOnly );
	_replyStream << setContextStyle(arg0 );
    } break;
    case 30: { // QString title()
	replyType = AmarokPlayerInterface_ftable[30][0]; 
	QDataStream _replyStream( replyData, IO_WriteOnly );
	_replyStream << title( );
    } break;
    case 31: { // QString totalTime()
	replyType = AmarokPlayerInterface_ftable[31][0]; 
	QDataStream _replyStream( replyData, IO_WriteOnly );
	_replyStream << totalTime( );
    } break;
    case 32: { // QString track()
	replyType = AmarokPlayerInterface_ftable[32][0]; 
	QDataStream _replyStream( replyData, IO_WriteOnly );
	_replyStream << track( );
    } break;
    case 33: { // QString type()
	replyType = AmarokPlayerInterface_ftable[33][0]; 
	QDataStream _replyStream( replyData, IO_WriteOnly );
	_replyStream << type( );
    } break;
    case 34: { // QString year()
	replyType = AmarokPlayerInterface_ftable[34][0]; 
	QDataStream _replyStream( replyData, IO_WriteOnly );
	_replyStream << year( );
    } break;
    case 35: { // void configEqualizer()
	replyType = AmarokPlayerInterface_ftable[35][0]; 
	configEqualizer( );
    } break;
    case 36: { // void enableOSD(bool)
	bool arg0;
	QDataStream arg( data, IO_ReadOnly );
	if (arg.atEnd()) return false;
	arg >> arg0;
	replyType = AmarokPlayerInterface_ftable[36][0]; 
	enableOSD(arg0 );
    } break;
    case 37: { // void enableRandomMode(bool)
	bool arg0;
	QDataStream arg( data, IO_ReadOnly );
	if (arg.atEnd()) return false;
	arg >> arg0;
	replyType = AmarokPlayerInterface_ftable[37][0]; 
	enableRandomMode(arg0 );
    } break;
    case 38: { // void enableRepeatPlaylist(bool)
	bool arg0;
	QDataStream arg( data, IO_ReadOnly );
	if (arg.atEnd()) return false;
	arg >> arg0;
	replyType = AmarokPlayerInterface_ftable[38][0]; 
	enableRepeatPlaylist(arg0 );
    } break;
    case 39: { // void enableRepeatTrack(bool)
	bool arg0;
	QDataStream arg( data, IO_ReadOnly );
	if (arg.atEnd()) return false;
	arg >> arg0;
	replyType = AmarokPlayerInterface_ftable[39][0]; 
	enableRepeatTrack(arg0 );
    } break;
    case 40: { // void mediaDeviceMount()
	replyType = AmarokPlayerInterface_ftable[40][0]; 
	mediaDeviceMount( );
    } break;
    case 41: { // void mediaDeviceUmount()
	replyType = AmarokPlayerInterface_ftable[41][0]; 
	mediaDeviceUmount( );
    } break;
    case 42: { // void mute()
	replyType = AmarokPlayerInterface_ftable[42][0]; 
	mute( );
    } break;
    case 43: { // void next()
	replyType = AmarokPlayerInterface_ftable[43][0]; 
	next( );
    } break;
    case 44: { // void pause()
	replyType = AmarokPlayerInterface_ftable[44][0]; 
	pause( );
    } break;
    case 45: { // void play()
	replyType = AmarokPlayerInterface_ftable[45][0]; 
	play( );
    } break;
    case 46: { // void playPause()
	replyType = AmarokPlayerInterface_ftable[46][0]; 
	playPause( );
    } break;
    case 47: { // void prev()
	replyType = AmarokPlayerInterface_ftable[47][0]; 
	prev( );
    } break;
    case 48: { // void queueForTransfer(KURL)
	KURL arg0;
	QDataStream arg( data, IO_ReadOnly );
	if (arg.atEnd()) return false;
	arg >> arg0;
	replyType = AmarokPlayerInterface_ftable[48][0]; 
	queueForTransfer(arg0 );
    } break;
    case 49: { // void seek(int)
	int arg0;
	QDataStream arg( data, IO_ReadOnly );
	if (arg.atEnd()) return false;
	arg >> arg0;
	replyType = AmarokPlayerInterface_ftable[49][0]; 
	seek(arg0 );
    } break;
    case 50: { // void seekRelative(int)
	int arg0;
	QDataStream arg( data, IO_ReadOnly );
	if (arg.atEnd()) return false;
	arg >> arg0;
	replyType = AmarokPlayerInterface_ftable[50][0]; 
	seekRelative(arg0 );
    } break;
    case 51: { // void setEqualizer(int,int,int,int,int,int,int,int,int,int,int)
	int arg0;
	int arg1;
	int arg2;
	int arg3;
	int arg4;
	int arg5;
	int arg6;
	int arg7;
	int arg8;
	int arg9;
	int arg10;
	QDataStream arg( data, IO_ReadOnly );
	if (arg.atEnd()) return false;
	arg >> arg0;
	if (arg.atEnd()) return false;
	arg >> arg1;
	if (arg.atEnd()) return false;
	arg >> arg2;
	if (arg.atEnd()) return false;
	arg >> arg3;
	if (arg.atEnd()) return false;
	arg >> arg4;
	if (arg.atEnd()) return false;
	arg >> arg5;
	if (arg.atEnd()) return false;
	arg >> arg6;
	if (arg.atEnd()) return false;
	arg >> arg7;
	if (arg.atEnd()) return false;
	arg >> arg8;
	if (arg.atEnd()) return false;
	arg >> arg9;
	if (arg.atEnd()) return false;
	arg >> arg10;
	replyType = AmarokPlayerInterface_ftable[51][0]; 
	setEqualizer(arg0, arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9, arg10 );
    } break;
    case 52: { // void setEqualizerEnabled(bool)
	bool arg0;
	QDataStream arg( data, IO_ReadOnly );
	if (arg.atEnd()) return false;
	arg >> arg0;
	replyType = AmarokPlayerInterface_ftable[52][0]; 
	setEqualizerEnabled(arg0 );
    } break;
    case 53: { // void setEqualizerPreset(QString)
	QString arg0;
	QDataStream arg( data, IO_ReadOnly );
	if (arg.atEnd()) return false;
	arg >> arg0;
	replyType = AmarokPlayerInterface_ftable[53][0]; 
	setEqualizerPreset(arg0 );
    } break;
    case 54: { // void setLyricsByPath(QString,QString)
	QString arg0;
	QString arg1;
	QDataStream arg( data, IO_ReadOnly );
	if (arg.atEnd()) return false;
	arg >> arg0;
	if (arg.atEnd()) return false;
	arg >> arg1;
	replyType = AmarokPlayerInterface_ftable[54][0]; 
	setLyricsByPath(arg0, arg1 );
    } break;
    case 55: { // void setScore(int)
	int arg0;
	QDataStream arg( data, IO_ReadOnly );
	if (arg.atEnd()) return false;
	arg >> arg0;
	replyType = AmarokPlayerInterface_ftable[55][0]; 
	setScore(arg0 );
    } break;
    case 56: { // void setScoreByPath(QString,int)
	QString arg0;
	int arg1;
	QDataStream arg( data, IO_ReadOnly );
	if (arg.atEnd()) return false;
	arg >> arg0;
	if (arg.atEnd()) return false;
	arg >> arg1;
	replyType = AmarokPlayerInterface_ftable[56][0]; 
	setScoreByPath(arg0, arg1 );
    } break;
    case 57: { // void setRating(int)
	int arg0;
	QDataStream arg( data, IO_ReadOnly );
	if (arg.atEnd()) return false;
	arg >> arg0;
	replyType = AmarokPlayerInterface_ftable[57][0]; 
	setRating(arg0 );
    } break;
    case 58: { // void setRatingByPath(QString,int)
	QString arg0;
	int arg1;
	QDataStream arg( data, IO_ReadOnly );
	if (arg.atEnd()) return false;
	arg >> arg0;
	if (arg.atEnd()) return false;
	arg >> arg1;
	replyType = AmarokPlayerInterface_ftable[58][0]; 
	setRatingByPath(arg0, arg1 );
    } break;
    case 59: { // void setVolume(int)
	int arg0;
	QDataStream arg( data, IO_ReadOnly );
	if (arg.atEnd()) return false;
	arg >> arg0;
	replyType = AmarokPlayerInterface_ftable[59][0]; 
	setVolume(arg0 );
    } break;
    case 60: { // void setVolumeRelative(int)
	int arg0;
	QDataStream arg( data, IO_ReadOnly );
	if (arg.atEnd()) return false;
	arg >> arg0;
	replyType = AmarokPlayerInterface_ftable[60][0]; 
	setVolumeRelative(arg0 );
    } break;
    case 61: { // void showBrowser(QString)
	QString arg0;
	QDataStream arg( data, IO_ReadOnly );
	if (arg.atEnd()) return false;
	arg >> arg0;
	replyType = AmarokPlayerInterface_ftable[61][0]; 
	showBrowser(arg0 );
    } break;
    case 62: { // void showOSD()
	replyType = AmarokPlayerInterface_ftable[62][0]; 
	showOSD( );
    } break;
    case 63: { // void stop()
	replyType = AmarokPlayerInterface_ftable[63][0]; 
	stop( );
    } break;
    case 64: { // void transferDeviceFiles()
	replyType = AmarokPlayerInterface_ftable[64][0]; 
	transferDeviceFiles( );
    } break;
    case 65: { // void volumeDown()
	replyType = AmarokPlayerInterface_ftable[65][0]; 
	volumeDown( );
    } break;
    case 66: { // void volumeUp()
	replyType = AmarokPlayerInterface_ftable[66][0]; 
	volumeUp( );
    } break;
    case 67: { // void transferCliArgs(QStringList)
	QStringList arg0;
	QDataStream arg( data, IO_ReadOnly );
	if (arg.atEnd()) return false;
	arg >> arg0;
	replyType = AmarokPlayerInterface_ftable[67][0]; 
	transferCliArgs(arg0 );
    } break;
    default: 
	return DCOPObject::process( fun, data, replyType, replyData );
    }
    return true;
}

QCStringList AmarokPlayerInterface::interfaces()
{
    QCStringList ifaces = DCOPObject::interfaces();
    ifaces += "AmarokPlayerInterface";
    return ifaces;
}

QCStringList AmarokPlayerInterface::functions()
{
    QCStringList funcs = DCOPObject::functions();
    for ( int i = 0; AmarokPlayerInterface_ftable[i][2]; i++ ) {
	if (AmarokPlayerInterface_ftable_hiddens[i])
	    continue;
	QCString func = AmarokPlayerInterface_ftable[i][0];
	func += ' ';
	func += AmarokPlayerInterface_ftable[i][2];
	funcs << func;
    }
    return funcs;
}


#include <kdatastream.h>
#include <qasciidict.h>


static const int AmarokPlaylistInterface_fhash = 19;
static const char* const AmarokPlaylistInterface_ftable[18][3] = {
    { "int", "getActiveIndex()", "getActiveIndex()" },
    { "int", "getTotalTrackCount()", "getTotalTrackCount()" },
    { "QString", "saveCurrentPlaylist()", "saveCurrentPlaylist()" },
    { "void", "addMedia(KURL)", "addMedia(KURL)" },
    { "void", "addMediaList(KURL::List)", "addMediaList(KURL::List)" },
    { "void", "clearPlaylist()", "clearPlaylist()" },
    { "void", "playByIndex(int)", "playByIndex(int)" },
    { "void", "playMedia(KURL)", "playMedia(KURL)" },
    { "void", "popupMessage(QString)", "popupMessage(QString)" },
    { "void", "removeCurrentTrack()", "removeCurrentTrack()" },
    { "void", "removeByIndex(int)", "removeByIndex(int)" },
    { "void", "repopulate()", "repopulate()" },
    { "void", "saveM3u(QString,bool)", "saveM3u(QString path,bool relativePaths)" },
    { "void", "setStopAfterCurrent(bool)", "setStopAfterCurrent(bool)" },
    { "void", "shortStatusMessage(QString)", "shortStatusMessage(QString)" },
    { "void", "shufflePlaylist()", "shufflePlaylist()" },
    { "void", "togglePlaylist()", "togglePlaylist()" },
    { 0, 0, 0 }
};
static const int AmarokPlaylistInterface_ftable_hiddens[17] = {
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
};

bool AmarokPlaylistInterface::process(const QCString &fun, const QByteArray &data, QCString& replyType, QByteArray &replyData)
{
    static QAsciiDict<int>* fdict = 0;
    if ( !fdict ) {
	fdict = new QAsciiDict<int>( AmarokPlaylistInterface_fhash, true, false );
	for ( int i = 0; AmarokPlaylistInterface_ftable[i][1]; i++ )
	    fdict->insert( AmarokPlaylistInterface_ftable[i][1],  new int( i ) );
    }
    int* fp = fdict->find( fun );
    switch ( fp?*fp:-1) {
    case 0: { // int getActiveIndex()
	replyType = AmarokPlaylistInterface_ftable[0][0]; 
	QDataStream _replyStream( replyData, IO_WriteOnly );
	_replyStream << getActiveIndex( );
    } break;
    case 1: { // int getTotalTrackCount()
	replyType = AmarokPlaylistInterface_ftable[1][0]; 
	QDataStream _replyStream( replyData, IO_WriteOnly );
	_replyStream << getTotalTrackCount( );
    } break;
    case 2: { // QString saveCurrentPlaylist()
	replyType = AmarokPlaylistInterface_ftable[2][0]; 
	QDataStream _replyStream( replyData, IO_WriteOnly );
	_replyStream << saveCurrentPlaylist( );
    } break;
    case 3: { // void addMedia(KURL)
	KURL arg0;
	QDataStream arg( data, IO_ReadOnly );
	if (arg.atEnd()) return false;
	arg >> arg0;
	replyType = AmarokPlaylistInterface_ftable[3][0]; 
	addMedia(arg0 );
    } break;
    case 4: { // void addMediaList(KURL::List)
	KURL::List arg0;
	QDataStream arg( data, IO_ReadOnly );
	if (arg.atEnd()) return false;
	arg >> arg0;
	replyType = AmarokPlaylistInterface_ftable[4][0]; 
	addMediaList(arg0 );
    } break;
    case 5: { // void clearPlaylist()
	replyType = AmarokPlaylistInterface_ftable[5][0]; 
	clearPlaylist( );
    } break;
    case 6: { // void playByIndex(int)
	int arg0;
	QDataStream arg( data, IO_ReadOnly );
	if (arg.atEnd()) return false;
	arg >> arg0;
	replyType = AmarokPlaylistInterface_ftable[6][0]; 
	playByIndex(arg0 );
    } break;
    case 7: { // void playMedia(KURL)
	KURL arg0;
	QDataStream arg( data, IO_ReadOnly );
	if (arg.atEnd()) return false;
	arg >> arg0;
	replyType = AmarokPlaylistInterface_ftable[7][0]; 
	playMedia(arg0 );
    } break;
    case 8: { // void popupMessage(QString)
	QString arg0;
	QDataStream arg( data, IO_ReadOnly );
	if (arg.atEnd()) return false;
	arg >> arg0;
	replyType = AmarokPlaylistInterface_ftable[8][0]; 
	popupMessage(arg0 );
    } break;
    case 9: { // void removeCurrentTrack()
	replyType = AmarokPlaylistInterface_ftable[9][0]; 
	removeCurrentTrack( );
    } break;
    case 10: { // void removeByIndex(int)
	int arg0;
	QDataStream arg( data, IO_ReadOnly );
	if (arg.atEnd()) return false;
	arg >> arg0;
	replyType = AmarokPlaylistInterface_ftable[10][0]; 
	removeByIndex(arg0 );
    } break;
    case 11: { // void repopulate()
	replyType = AmarokPlaylistInterface_ftable[11][0]; 
	repopulate( );
    } break;
    case 12: { // void saveM3u(QString,bool)
	QString arg0;
	bool arg1;
	QDataStream arg( data, IO_ReadOnly );
	if (arg.atEnd()) return false;
	arg >> arg0;
	if (arg.atEnd()) return false;
	arg >> arg1;
	replyType = AmarokPlaylistInterface_ftable[12][0]; 
	saveM3u(arg0, arg1 );
    } break;
    case 13: { // void setStopAfterCurrent(bool)
	bool arg0;
	QDataStream arg( data, IO_ReadOnly );
	if (arg.atEnd()) return false;
	arg >> arg0;
	replyType = AmarokPlaylistInterface_ftable[13][0]; 
	setStopAfterCurrent(arg0 );
    } break;
    case 14: { // void shortStatusMessage(QString)
	QString arg0;
	QDataStream arg( data, IO_ReadOnly );
	if (arg.atEnd()) return false;
	arg >> arg0;
	replyType = AmarokPlaylistInterface_ftable[14][0]; 
	shortStatusMessage(arg0 );
    } break;
    case 15: { // void shufflePlaylist()
	replyType = AmarokPlaylistInterface_ftable[15][0]; 
	shufflePlaylist( );
    } break;
    case 16: { // void togglePlaylist()
	replyType = AmarokPlaylistInterface_ftable[16][0]; 
	togglePlaylist( );
    } break;
    default: 
	return DCOPObject::process( fun, data, replyType, replyData );
    }
    return true;
}

QCStringList AmarokPlaylistInterface::interfaces()
{
    QCStringList ifaces = DCOPObject::interfaces();
    ifaces += "AmarokPlaylistInterface";
    return ifaces;
}

QCStringList AmarokPlaylistInterface::functions()
{
    QCStringList funcs = DCOPObject::functions();
    for ( int i = 0; AmarokPlaylistInterface_ftable[i][2]; i++ ) {
	if (AmarokPlaylistInterface_ftable_hiddens[i])
	    continue;
	QCString func = AmarokPlaylistInterface_ftable[i][0];
	func += ' ';
	func += AmarokPlaylistInterface_ftable[i][2];
	funcs << func;
    }
    return funcs;
}


#include <kdatastream.h>


static const char* const AmarokPlaylistBrowserInterface_ftable[5][3] = {
    { "void", "addPodcast(QString)", "addPodcast(QString)" },
    { "void", "scanPodcasts()", "scanPodcasts()" },
    { "void", "addPlaylist(QString)", "addPlaylist(QString)" },
    { "int", "loadPlaylist(QString)", "loadPlaylist(QString)" },
    { 0, 0, 0 }
};
static const int AmarokPlaylistBrowserInterface_ftable_hiddens[4] = {
    0,
    0,
    0,
    0,
};

bool AmarokPlaylistBrowserInterface::process(const QCString &fun, const QByteArray &data, QCString& replyType, QByteArray &replyData)
{
    if ( fun == AmarokPlaylistBrowserInterface_ftable[0][1] ) { // void addPodcast(QString)
	QString arg0;
	QDataStream arg( data, IO_ReadOnly );
	if (arg.atEnd()) return false;
	arg >> arg0;
	replyType = AmarokPlaylistBrowserInterface_ftable[0][0]; 
	addPodcast(arg0 );
    } else if ( fun == AmarokPlaylistBrowserInterface_ftable[1][1] ) { // void scanPodcasts()
	replyType = AmarokPlaylistBrowserInterface_ftable[1][0]; 
	scanPodcasts( );
    } else if ( fun == AmarokPlaylistBrowserInterface_ftable[2][1] ) { // void addPlaylist(QString)
	QString arg0;
	QDataStream arg( data, IO_ReadOnly );
	if (arg.atEnd()) return false;
	arg >> arg0;
	replyType = AmarokPlaylistBrowserInterface_ftable[2][0]; 
	addPlaylist(arg0 );
    } else if ( fun == AmarokPlaylistBrowserInterface_ftable[3][1] ) { // int loadPlaylist(QString)
	QString arg0;
	QDataStream arg( data, IO_ReadOnly );
	if (arg.atEnd()) return false;
	arg >> arg0;
	replyType = AmarokPlaylistBrowserInterface_ftable[3][0]; 
	QDataStream _replyStream( replyData, IO_WriteOnly );
	_replyStream << loadPlaylist(arg0 );
    } else {
	return DCOPObject::process( fun, data, replyType, replyData );
    }
    return true;
}

QCStringList AmarokPlaylistBrowserInterface::interfaces()
{
    QCStringList ifaces = DCOPObject::interfaces();
    ifaces += "AmarokPlaylistBrowserInterface";
    return ifaces;
}

QCStringList AmarokPlaylistBrowserInterface::functions()
{
    QCStringList funcs = DCOPObject::functions();
    for ( int i = 0; AmarokPlaylistBrowserInterface_ftable[i][2]; i++ ) {
	if (AmarokPlaylistBrowserInterface_ftable_hiddens[i])
	    continue;
	QCString func = AmarokPlaylistBrowserInterface_ftable[i][0];
	func += ' ';
	func += AmarokPlaylistBrowserInterface_ftable[i][2];
	funcs << func;
    }
    return funcs;
}


#include <kdatastream.h>


static const char* const AmarokContextBrowserInterface_ftable[5][3] = {
    { "void", "showCurrentTrack()", "showCurrentTrack()" },
    { "void", "showLyrics()", "showLyrics()" },
    { "void", "showWiki()", "showWiki()" },
    { "void", "showLyrics(QCString)", "showLyrics(QCString lyrics)" },
    { 0, 0, 0 }
};
static const int AmarokContextBrowserInterface_ftable_hiddens[4] = {
    0,
    0,
    0,
    0,
};

bool AmarokContextBrowserInterface::process(const QCString &fun, const QByteArray &data, QCString& replyType, QByteArray &replyData)
{
    if ( fun == AmarokContextBrowserInterface_ftable[0][1] ) { // void showCurrentTrack()
	replyType = AmarokContextBrowserInterface_ftable[0][0]; 
	showCurrentTrack( );
    } else if ( fun == AmarokContextBrowserInterface_ftable[1][1] ) { // void showLyrics()
	replyType = AmarokContextBrowserInterface_ftable[1][0]; 
	showLyrics( );
    } else if ( fun == AmarokContextBrowserInterface_ftable[2][1] ) { // void showWiki()
	replyType = AmarokContextBrowserInterface_ftable[2][0]; 
	showWiki( );
    } else if ( fun == AmarokContextBrowserInterface_ftable[3][1] ) { // void showLyrics(QCString)
	QCString arg0;
	QDataStream arg( data, IO_ReadOnly );
	if (arg.atEnd()) return false;
	arg >> arg0;
	replyType = AmarokContextBrowserInterface_ftable[3][0]; 
	showLyrics(arg0 );
    } else {
	return DCOPObject::process( fun, data, replyType, replyData );
    }
    return true;
}

QCStringList AmarokContextBrowserInterface::interfaces()
{
    QCStringList ifaces = DCOPObject::interfaces();
    ifaces += "AmarokContextBrowserInterface";
    return ifaces;
}

QCStringList AmarokContextBrowserInterface::functions()
{
    QCStringList funcs = DCOPObject::functions();
    for ( int i = 0; AmarokContextBrowserInterface_ftable[i][2]; i++ ) {
	if (AmarokContextBrowserInterface_ftable_hiddens[i])
	    continue;
	QCString func = AmarokContextBrowserInterface_ftable[i][0];
	func += ' ';
	func += AmarokContextBrowserInterface_ftable[i][2];
	funcs << func;
    }
    return funcs;
}


#include <kdatastream.h>
#include <qasciidict.h>


static const int AmarokCollectionInterface_fhash = 17;
static const char* const AmarokCollectionInterface_ftable[16][3] = {
    { "int", "totalAlbums()", "totalAlbums()" },
    { "int", "totalArtists()", "totalArtists()" },
    { "int", "totalCompilations()", "totalCompilations()" },
    { "int", "totalGenres()", "totalGenres()" },
    { "int", "totalTracks()", "totalTracks()" },
    { "bool", "isDirInCollection(QString)", "isDirInCollection(QString)" },
    { "bool", "moveFile(QString,QString,bool)", "moveFile(QString oldURL,QString newURL,bool overwrite)" },
    { "QStringList", "query(QString)", "query(QString sql)" },
    { "QStringList", "similarArtists(int)", "similarArtists(int artists)" },
    { "void", "migrateFile(QString,QString)", "migrateFile(QString oldURL,QString newURL)" },
    { "void", "scanCollection()", "scanCollection()" },
    { "void", "scanCollectionChanges()", "scanCollectionChanges()" },
    { "void", "disableAutoScoring(bool)", "disableAutoScoring(bool disable)" },
    { "void", "newUniqueIdForFile(QString)", "newUniqueIdForFile(QString path)" },
    { "void", "newUniqueIdForFiles(QStringList)", "newUniqueIdForFiles(QStringList list)" },
    { 0, 0, 0 }
};
static const int AmarokCollectionInterface_ftable_hiddens[15] = {
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
};

bool AmarokCollectionInterface::process(const QCString &fun, const QByteArray &data, QCString& replyType, QByteArray &replyData)
{
    static QAsciiDict<int>* fdict = 0;
    if ( !fdict ) {
	fdict = new QAsciiDict<int>( AmarokCollectionInterface_fhash, true, false );
	for ( int i = 0; AmarokCollectionInterface_ftable[i][1]; i++ )
	    fdict->insert( AmarokCollectionInterface_ftable[i][1],  new int( i ) );
    }
    int* fp = fdict->find( fun );
    switch ( fp?*fp:-1) {
    case 0: { // int totalAlbums()
	replyType = AmarokCollectionInterface_ftable[0][0]; 
	QDataStream _replyStream( replyData, IO_WriteOnly );
	_replyStream << totalAlbums( );
    } break;
    case 1: { // int totalArtists()
	replyType = AmarokCollectionInterface_ftable[1][0]; 
	QDataStream _replyStream( replyData, IO_WriteOnly );
	_replyStream << totalArtists( );
    } break;
    case 2: { // int totalCompilations()
	replyType = AmarokCollectionInterface_ftable[2][0]; 
	QDataStream _replyStream( replyData, IO_WriteOnly );
	_replyStream << totalCompilations( );
    } break;
    case 3: { // int totalGenres()
	replyType = AmarokCollectionInterface_ftable[3][0]; 
	QDataStream _replyStream( replyData, IO_WriteOnly );
	_replyStream << totalGenres( );
    } break;
    case 4: { // int totalTracks()
	replyType = AmarokCollectionInterface_ftable[4][0]; 
	QDataStream _replyStream( replyData, IO_WriteOnly );
	_replyStream << totalTracks( );
    } break;
    case 5: { // bool isDirInCollection(QString)
	QString arg0;
	QDataStream arg( data, IO_ReadOnly );
	if (arg.atEnd()) return false;
	arg >> arg0;
	replyType = AmarokCollectionInterface_ftable[5][0]; 
	QDataStream _replyStream( replyData, IO_WriteOnly );
	_replyStream << isDirInCollection(arg0 );
    } break;
    case 6: { // bool moveFile(QString,QString,bool)
	QString arg0;
	QString arg1;
	bool arg2;
	QDataStream arg( data, IO_ReadOnly );
	if (arg.atEnd()) return false;
	arg >> arg0;
	if (arg.atEnd()) return false;
	arg >> arg1;
	if (arg.atEnd()) return false;
	arg >> arg2;
	replyType = AmarokCollectionInterface_ftable[6][0]; 
	QDataStream _replyStream( replyData, IO_WriteOnly );
	_replyStream << moveFile(arg0, arg1, arg2 );
    } break;
    case 7: { // QStringList query(QString)
	QString arg0;
	QDataStream arg( data, IO_ReadOnly );
	if (arg.atEnd()) return false;
	arg >> arg0;
	replyType = AmarokCollectionInterface_ftable[7][0]; 
	QDataStream _replyStream( replyData, IO_WriteOnly );
	_replyStream << query(arg0 );
    } break;
    case 8: { // QStringList similarArtists(int)
	int arg0;
	QDataStream arg( data, IO_ReadOnly );
	if (arg.atEnd()) return false;
	arg >> arg0;
	replyType = AmarokCollectionInterface_ftable[8][0]; 
	QDataStream _replyStream( replyData, IO_WriteOnly );
	_replyStream << similarArtists(arg0 );
    } break;
    case 9: { // void migrateFile(QString,QString)
	QString arg0;
	QString arg1;
	QDataStream arg( data, IO_ReadOnly );
	if (arg.atEnd()) return false;
	arg >> arg0;
	if (arg.atEnd()) return false;
	arg >> arg1;
	replyType = AmarokCollectionInterface_ftable[9][0]; 
	migrateFile(arg0, arg1 );
    } break;
    case 10: { // void scanCollection()
	replyType = AmarokCollectionInterface_ftable[10][0]; 
	scanCollection( );
    } break;
    case 11: { // void scanCollectionChanges()
	replyType = AmarokCollectionInterface_ftable[11][0]; 
	scanCollectionChanges( );
    } break;
    case 12: { // void disableAutoScoring(bool)
	bool arg0;
	QDataStream arg( data, IO_ReadOnly );
	if (arg.atEnd()) return false;
	arg >> arg0;
	replyType = AmarokCollectionInterface_ftable[12][0]; 
	disableAutoScoring(arg0 );
    } break;
    case 13: { // void newUniqueIdForFile(QString)
	QString arg0;
	QDataStream arg( data, IO_ReadOnly );
	if (arg.atEnd()) return false;
	arg >> arg0;
	replyType = AmarokCollectionInterface_ftable[13][0]; 
	newUniqueIdForFile(arg0 );
    } break;
    case 14: { // void newUniqueIdForFiles(QStringList)
	QStringList arg0;
	QDataStream arg( data, IO_ReadOnly );
	if (arg.atEnd()) return false;
	arg >> arg0;
	replyType = AmarokCollectionInterface_ftable[14][0]; 
	newUniqueIdForFiles(arg0 );
    } break;
    default: 
	return DCOPObject::process( fun, data, replyType, replyData );
    }
    return true;
}

QCStringList AmarokCollectionInterface::interfaces()
{
    QCStringList ifaces = DCOPObject::interfaces();
    ifaces += "AmarokCollectionInterface";
    return ifaces;
}

QCStringList AmarokCollectionInterface::functions()
{
    QCStringList funcs = DCOPObject::functions();
    for ( int i = 0; AmarokCollectionInterface_ftable[i][2]; i++ ) {
	if (AmarokCollectionInterface_ftable_hiddens[i])
	    continue;
	QCString func = AmarokCollectionInterface_ftable[i][0];
	func += ' ';
	func += AmarokCollectionInterface_ftable[i][2];
	funcs << func;
    }
    return funcs;
}


#include <kdatastream.h>


static const char* const AmarokScriptInterface_ftable[8][3] = {
    { "bool", "runScript(QString)", "runScript(QString name)" },
    { "bool", "stopScript(QString)", "stopScript(QString name)" },
    { "QStringList", "listRunningScripts()", "listRunningScripts()" },
    { "void", "addCustomMenuItem(QString,QString)", "addCustomMenuItem(QString submenu,QString itemTitle)" },
    { "void", "removeCustomMenuItem(QString,QString)", "removeCustomMenuItem(QString submenu,QString itemTitle)" },
    { "QString", "readConfig(QString)", "readConfig(QString key)" },
    { "QStringList", "readListConfig(QString)", "readListConfig(QString key)" },
    { 0, 0, 0 }
};
static const int AmarokScriptInterface_ftable_hiddens[7] = {
    0,
    0,
    0,
    0,
    0,
    0,
    0,
};

bool AmarokScriptInterface::process(const QCString &fun, const QByteArray &data, QCString& replyType, QByteArray &replyData)
{
    if ( fun == AmarokScriptInterface_ftable[0][1] ) { // bool runScript(QString)
	QString arg0;
	QDataStream arg( data, IO_ReadOnly );
	if (arg.atEnd()) return false;
	arg >> arg0;
	replyType = AmarokScriptInterface_ftable[0][0]; 
	QDataStream _replyStream( replyData, IO_WriteOnly );
	_replyStream << runScript(arg0 );
    } else if ( fun == AmarokScriptInterface_ftable[1][1] ) { // bool stopScript(QString)
	QString arg0;
	QDataStream arg( data, IO_ReadOnly );
	if (arg.atEnd()) return false;
	arg >> arg0;
	replyType = AmarokScriptInterface_ftable[1][0]; 
	QDataStream _replyStream( replyData, IO_WriteOnly );
	_replyStream << stopScript(arg0 );
    } else if ( fun == AmarokScriptInterface_ftable[2][1] ) { // QStringList listRunningScripts()
	replyType = AmarokScriptInterface_ftable[2][0]; 
	QDataStream _replyStream( replyData, IO_WriteOnly );
	_replyStream << listRunningScripts( );
    } else if ( fun == AmarokScriptInterface_ftable[3][1] ) { // void addCustomMenuItem(QString,QString)
	QString arg0;
	QString arg1;
	QDataStream arg( data, IO_ReadOnly );
	if (arg.atEnd()) return false;
	arg >> arg0;
	if (arg.atEnd()) return false;
	arg >> arg1;
	replyType = AmarokScriptInterface_ftable[3][0]; 
	addCustomMenuItem(arg0, arg1 );
    } else if ( fun == AmarokScriptInterface_ftable[4][1] ) { // void removeCustomMenuItem(QString,QString)
	QString arg0;
	QString arg1;
	QDataStream arg( data, IO_ReadOnly );
	if (arg.atEnd()) return false;
	arg >> arg0;
	if (arg.atEnd()) return false;
	arg >> arg1;
	replyType = AmarokScriptInterface_ftable[4][0]; 
	removeCustomMenuItem(arg0, arg1 );
    } else if ( fun == AmarokScriptInterface_ftable[5][1] ) { // QString readConfig(QString)
	QString arg0;
	QDataStream arg( data, IO_ReadOnly );
	if (arg.atEnd()) return false;
	arg >> arg0;
	replyType = AmarokScriptInterface_ftable[5][0]; 
	QDataStream _replyStream( replyData, IO_WriteOnly );
	_replyStream << readConfig(arg0 );
    } else if ( fun == AmarokScriptInterface_ftable[6][1] ) { // QStringList readListConfig(QString)
	QString arg0;
	QDataStream arg( data, IO_ReadOnly );
	if (arg.atEnd()) return false;
	arg >> arg0;
	replyType = AmarokScriptInterface_ftable[6][0]; 
	QDataStream _replyStream( replyData, IO_WriteOnly );
	_replyStream << readListConfig(arg0 );
    } else {
	return DCOPObject::process( fun, data, replyType, replyData );
    }
    return true;
}

QCStringList AmarokScriptInterface::interfaces()
{
    QCStringList ifaces = DCOPObject::interfaces();
    ifaces += "AmarokScriptInterface";
    return ifaces;
}

QCStringList AmarokScriptInterface::functions()
{
    QCStringList funcs = DCOPObject::functions();
    for ( int i = 0; AmarokScriptInterface_ftable[i][2]; i++ ) {
	if (AmarokScriptInterface_ftable_hiddens[i])
	    continue;
	QCString func = AmarokScriptInterface_ftable[i][0];
	func += ' ';
	func += AmarokScriptInterface_ftable[i][2];
	funcs << func;
    }
    return funcs;
}


#include <kdatastream.h>


static const char* const AmarokDevicesInterface_ftable[5][3] = {
    { "void", "mediumAdded(QString)", "mediumAdded(QString name)" },
    { "void", "mediumRemoved(QString)", "mediumRemoved(QString name)" },
    { "void", "mediumChanged(QString)", "mediumChanged(QString name)" },
    { "QStringList", "showDeviceList()", "showDeviceList()" },
    { 0, 0, 0 }
};
static const int AmarokDevicesInterface_ftable_hiddens[4] = {
    0,
    0,
    0,
    0,
};

bool AmarokDevicesInterface::process(const QCString &fun, const QByteArray &data, QCString& replyType, QByteArray &replyData)
{
    if ( fun == AmarokDevicesInterface_ftable[0][1] ) { // void mediumAdded(QString)
	QString arg0;
	QDataStream arg( data, IO_ReadOnly );
	if (arg.atEnd()) return false;
	arg >> arg0;
	replyType = AmarokDevicesInterface_ftable[0][0]; 
	mediumAdded(arg0 );
    } else if ( fun == AmarokDevicesInterface_ftable[1][1] ) { // void mediumRemoved(QString)
	QString arg0;
	QDataStream arg( data, IO_ReadOnly );
	if (arg.atEnd()) return false;
	arg >> arg0;
	replyType = AmarokDevicesInterface_ftable[1][0]; 
	mediumRemoved(arg0 );
    } else if ( fun == AmarokDevicesInterface_ftable[2][1] ) { // void mediumChanged(QString)
	QString arg0;
	QDataStream arg( data, IO_ReadOnly );
	if (arg.atEnd()) return false;
	arg >> arg0;
	replyType = AmarokDevicesInterface_ftable[2][0]; 
	mediumChanged(arg0 );
    } else if ( fun == AmarokDevicesInterface_ftable[3][1] ) { // QStringList showDeviceList()
	replyType = AmarokDevicesInterface_ftable[3][0]; 
	QDataStream _replyStream( replyData, IO_WriteOnly );
	_replyStream << showDeviceList( );
    } else {
	return DCOPObject::process( fun, data, replyType, replyData );
    }
    return true;
}

QCStringList AmarokDevicesInterface::interfaces()
{
    QCStringList ifaces = DCOPObject::interfaces();
    ifaces += "AmarokDevicesInterface";
    return ifaces;
}

QCStringList AmarokDevicesInterface::functions()
{
    QCStringList funcs = DCOPObject::functions();
    for ( int i = 0; AmarokDevicesInterface_ftable[i][2]; i++ ) {
	if (AmarokDevicesInterface_ftable_hiddens[i])
	    continue;
	QCString func = AmarokDevicesInterface_ftable[i][0];
	func += ' ';
	func += AmarokDevicesInterface_ftable[i][2];
	funcs << func;
    }
    return funcs;
}


#include <kdatastream.h>
#include <qasciidict.h>


static const int AmarokMediaBrowserInterface_fhash = 11;
static const char* const AmarokMediaBrowserInterface_ftable[9][3] = {
    { "void", "deviceConnect()", "deviceConnect()" },
    { "void", "deviceDisconnect()", "deviceDisconnect()" },
    { "void", "deviceSwitch(QString)", "deviceSwitch(QString name)" },
    { "QStringList", "deviceList()", "deviceList()" },
    { "void", "queue(KURL)", "queue(KURL url)" },
    { "void", "queueList(KURL::List)", "queueList(KURL::List url)" },
    { "void", "transfer()", "transfer()" },
    { "void", "transcodingFinished(QString,QString)", "transcodingFinished(QString src,QString dest)" },
    { 0, 0, 0 }
};
static const int AmarokMediaBrowserInterface_ftable_hiddens[8] = {
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
};

bool AmarokMediaBrowserInterface::process(const QCString &fun, const QByteArray &data, QCString& replyType, QByteArray &replyData)
{
    static QAsciiDict<int>* fdict = 0;
    if ( !fdict ) {
	fdict = new QAsciiDict<int>( AmarokMediaBrowserInterface_fhash, true, false );
	for ( int i = 0; AmarokMediaBrowserInterface_ftable[i][1]; i++ )
	    fdict->insert( AmarokMediaBrowserInterface_ftable[i][1],  new int( i ) );
    }
    int* fp = fdict->find( fun );
    switch ( fp?*fp:-1) {
    case 0: { // void deviceConnect()
	replyType = AmarokMediaBrowserInterface_ftable[0][0]; 
	deviceConnect( );
    } break;
    case 1: { // void deviceDisconnect()
	replyType = AmarokMediaBrowserInterface_ftable[1][0]; 
	deviceDisconnect( );
    } break;
    case 2: { // void deviceSwitch(QString)
	QString arg0;
	QDataStream arg( data, IO_ReadOnly );
	if (arg.atEnd()) return false;
	arg >> arg0;
	replyType = AmarokMediaBrowserInterface_ftable[2][0]; 
	deviceSwitch(arg0 );
    } break;
    case 3: { // QStringList deviceList()
	replyType = AmarokMediaBrowserInterface_ftable[3][0]; 
	QDataStream _replyStream( replyData, IO_WriteOnly );
	_replyStream << deviceList( );
    } break;
    case 4: { // void queue(KURL)
	KURL arg0;
	QDataStream arg( data, IO_ReadOnly );
	if (arg.atEnd()) return false;
	arg >> arg0;
	replyType = AmarokMediaBrowserInterface_ftable[4][0]; 
	queue(arg0 );
    } break;
    case 5: { // void queueList(KURL::List)
	KURL::List arg0;
	QDataStream arg( data, IO_ReadOnly );
	if (arg.atEnd()) return false;
	arg >> arg0;
	replyType = AmarokMediaBrowserInterface_ftable[5][0]; 
	queueList(arg0 );
    } break;
    case 6: { // void transfer()
	replyType = AmarokMediaBrowserInterface_ftable[6][0]; 
	transfer( );
    } break;
    case 7: { // void transcodingFinished(QString,QString)
	QString arg0;
	QString arg1;
	QDataStream arg( data, IO_ReadOnly );
	if (arg.atEnd()) return false;
	arg >> arg0;
	if (arg.atEnd()) return false;
	arg >> arg1;
	replyType = AmarokMediaBrowserInterface_ftable[7][0]; 
	transcodingFinished(arg0, arg1 );
    } break;
    default: 
	return DCOPObject::process( fun, data, replyType, replyData );
    }
    return true;
}

QCStringList AmarokMediaBrowserInterface::interfaces()
{
    QCStringList ifaces = DCOPObject::interfaces();
    ifaces += "AmarokMediaBrowserInterface";
    return ifaces;
}

QCStringList AmarokMediaBrowserInterface::functions()
{
    QCStringList funcs = DCOPObject::functions();
    for ( int i = 0; AmarokMediaBrowserInterface_ftable[i][2]; i++ ) {
	if (AmarokMediaBrowserInterface_ftable_hiddens[i])
	    continue;
	QCString func = AmarokMediaBrowserInterface_ftable[i][0];
	func += ' ';
	func += AmarokMediaBrowserInterface_ftable[i][2];
	funcs << func;
    }
    return funcs;
}


